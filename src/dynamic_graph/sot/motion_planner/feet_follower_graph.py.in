#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright 2011, Florent Lamiraux, Thomas Moulard, JRL, CNRS/AIST
#
# This file is part of dynamic-graph.
# dynamic-graph is free software: you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation, either version 3 of
# the License, or (at your option) any later version.
#
# dynamic-graph is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Lesser Public License for more details.  You should have
# received a copy of the GNU Lesser General Public License along with
# dynamic-graph. If not, see <http://www.gnu.org/licenses/>.

from dynamic_graph import plug
from __main__ import robot, solver
from dynamic_graph.sot.core import FeatureGeneric, Task, RobotSimu
from dynamic_graph.sot.motion_planner import \
    FeetFollowerFromFile, FeetFollowerAnalyticalPg, PostureError, \
    WaistYaw
from dynamic_graph.tracer_real_time import TracerRealTime

def translationToSE3(t):
    return ((1., 0., 0., t[0]),
            (0., 1., 0., t[1]),
            (0., 0., 1., t[2]),
            (0., 0., 0., 1.  ))

def oneVector(i):
    r = [0.,] * 36
    r[i] = 1.
    return tuple(r)

class FeetFollowerGraph:
    feetFollower = None

    postureTask = None
    postureFeature = None
    postureFeatureDes = None
    postureError = None
    trace = None

    def __init__(self):
        self.trace = TracerRealTime('trace')
        self.trace.setBufferSize(2**20)
        self.trace.open('/tmp/','feet_follower_','.dat')

        for s in robot.OperationalPoints + ["com", "zmp"]:
            self.trace.add(robot.dynamic.name + '.' + s,
                           robot.dynamic.name + '-' + s)
            robot.device.after.addSignal(robot.dynamic.name + '.' + s)

        for s in robot.OperationalPoints:
            self.trace.add(
                robot.features[s]._reference.name + '.position',
                robot.features[s]._reference.name + '-position')
            robot.device.after.addSignal(
                robot.features[s]._reference.name + '.position')

            self.trace.add(
                robot.tasks[s].name + '.error',
                robot.tasks[s].name + '-error')
            robot.device.after.addSignal(
                robot.tasks[s].name + '.error')


        self.trace.add(robot.featureComDes.name + '.errorIN',
                       robot.featureComDes.name + '-errorIN')
        robot.device.after.addSignal(robot.featureComDes.name + '.errorIN')

        self.trace.add(robot.comTask.name + '.error',
                       robot.comTask.name + '-error')
        robot.device.after.addSignal(robot.comTask.name + '.error')

        self.trace.add(robot.device.name + '.zmp', robot.device.name + '-zmp')
        robot.device.after.addSignal(robot.device.name + '.zmp')

        # Recompute trace.triger at each iteration to enable tracing.
        robot.device.after.addSignal(self.trace.name +'.triger')

        #self.trace.start()

    def setAnklePosition(self):
        # Setup feet to ankle transformation.
        anklePosL = robot.dynamic.getAnklePositionInFootFrame()
        anklePosR = (anklePosL[0], -anklePosL[1], anklePosL[2])

        self.feetFollower.setLeftFootToAnkle(translationToSE3(anklePosL))
        self.feetFollower.setRightFootToAnkle(translationToSE3(anklePosR))

    def setInitialFeetPosition(self):
        self.feetFollower.setInitialLeftAnklePosition(
            robot.features['left-ankle'].reference.value)
        self.feetFollower.setInitialRightAnklePosition(
            robot.features['right-ankle'].reference.value)

    def setup(self):
        initialGain = 1.

        #robot.features['left-ankle']._reference.frame("current")
        #robot.features['right-ankle']._reference.frame("current")

        # Lower the gains to reduce the initial velocity.
        robot.comTask.controlGain.value = initialGain
        robot.tasks['left-ankle'].controlGain.value = initialGain
        robot.tasks['right-ankle'].controlGain.value = initialGain

        # Make sure the CoM is converging toward the starting
        # CoM of the trajectory.
        robot.featureComDes.errorIN.value = \
            (0., 0., robot.dynamic.com.value[2])
        robot.featureCom.selec.value = '111'

        # Plug the feet follower output signals.
        plug(self.feetFollower.zmp, robot.device.zmp)

        plug(self.feetFollower.com, robot.featureComDes.errorIN)
        plug(self.feetFollower.signal('left-ankle'),
             robot.features['left-ankle'].reference)
        plug(self.feetFollower.signal('right-ankle'),
             robot.features['right-ankle'].reference)

        # Initialize the posture task.
        self.postureTask = Task(robot.name + '_posture')
        self.postureFeature = FeatureGeneric(robot.name + '_postureFeature')
        self.postureError = PostureError('PostureError')

        posture = list(robot.halfSitting)
        posture[6 + 17] -= 0.2
        posture[6 + 24] += 0.2
        self.postureError.setPosture(tuple(posture))

        plug(robot.device.state, self.postureError.state)
        plug(self.postureError.error, self.postureFeature.errorIN)
        self.postureFeature.jacobianIN.value = self.computeJacobianPosture()
        self.postureTask.add(self.postureFeature.name)
        self.postureTask.controlGain.value = initialGain

        # Initialize the waist yaw task.
        robot.features['waist'].selec.value = '111000'
        plug(self.feetFollower.waistYaw, robot.features['waist'].reference)
        robot.tasks['waist'].controlGain.value = initialGain

        # Tasks
        solver.sot.remove(robot.tasks['right-ankle'].name)
        solver.sot.remove(robot.tasks['left-ankle'].name)
        solver.sot.remove(robot.comTask.name)

        solver.sot.push(self.postureTask.name)
        solver.sot.push(robot.comTask.name)
        solver.sot.push(robot.tasks['left-ankle'].name)
        solver.sot.push(robot.tasks['right-ankle'].name)
        solver.sot.push(robot.tasks['waist'].name)

    def setupTrace(self):
        # Feature sdes input.
        self.trace.add(self.feetFollower.name + '.com',
                       self.feetFollower.name + '-com')
        self.trace.add(self.feetFollower.name + '.zmp',
                       self.feetFollower.name + '-zmp')
        self.trace.add(self.feetFollower.name + '.left-ankle',
                       self.feetFollower.name + '-left-ankle')
        self.trace.add(self.feetFollower.name + '.right-ankle',
                       self.feetFollower.name + '-right-ankle')
        self.trace.add(self.feetFollower.name + '.waistYaw',
                       self.feetFollower.name + '-waistYaw')

        robot.device.after.addSignal(self.feetFollower.name + '.zmp')

        # Tasks error sdes input.
        self.trace.add(robot.comTask.name + '.error', 'errorCom')
        self.trace.add(robot.tasks['left-ankle'].name + '.error', 'errorLa')
        self.trace.add(robot.tasks['right-ankle'].name + '.error', 'errorRa')
        self.trace.add(robot.tasks['waist'].name + '.error', 'errorWaist')
        self.trace.add(self.postureTask.name + '.error', 'errorPosture')

    def computeJacobianPosture(self):
        j = []
        for i in xrange(36):
            if i >= 6 + 2 * 6:
                j.append(oneVector(i))
        return tuple(j)

    def canStart(self):
        securityThreshold = 1e-3
        return (robot.comTask.error.value <=
                (securityThreshold,) * len(robot.comTask.error.value)

                and robot.tasks['left-ankle'].error.value <=
                (securityThreshold,)
                * len(robot.tasks['left-ankle'].error.value)

                and robot.tasks['right-ankle'].error.value <=
                (securityThreshold,)
                * len(robot.tasks['right-ankle'].error.value)

                and self.postureTask.error.value <=
                (securityThreshold,) * len(self.postureTask.error.value))

    def start(self, beforeStart=None):
        if not self.canStart():
            print("Robot has not yet converged to the initial position,"
                  " please wait and try again.")
            return
        robot.comTask.controlGain.value = 180.
        robot.tasks['left-ankle'].controlGain.value = 180.
        robot.tasks['right-ankle'].controlGain.value = 180.
        self.postureTask.controlGain.value = 180.
        robot.tasks['waist'].controlGain.value = 180.
        self.setupTrace()
        if beforeStart:
            beforeStart()
        self.trace.start()
        self.feetFollower.start()

class FeetFollowerFromFileGraph(FeetFollowerGraph):
    defaultTrajectoryDirectory = '@TRAJECTORY_PATH@'

    # Slow trajectory.
    defaultTrajectoryPath = defaultTrajectoryDirectory + '/simple_trajectory'

    def __init__(self, trajectoryPath = defaultTrajectoryPath):
        FeetFollowerGraph.__init__(self)
        self.feetFollower = FeetFollowerFromFile('feet-follower')
        self.setAnklePosition()
        self.setInitialFeetPosition()
        self.feetFollower.setComZ(0.814)
        self.feetFollower.readTrajectory(trajectoryPath)
        self.setup()


class FeetFollowerAnalyticalPgGraph(FeetFollowerGraph):
    # Parameters are:
    # - first slide
    # - horizontal distance
    # - maximum feet height
    # - second slide
    # - x
    # - y
    # - theta

    defaultSteps = [
        (-0.,  0.24, 0.25,-0., 0.31,-0.00, 0.),
        ]

    def __init__(self, steps = defaultSteps, comZ = None):
        FeetFollowerGraph.__init__(self)
        self.feetFollower = FeetFollowerAnalyticalPg('feet-follower')
        self.setAnklePosition()
        self.setInitialFeetPosition()
        if comZ:
            self.feetFollower.setComZ(comZ)
        else:
            self.feetFollower.setComZ(robot.dynamic.com.value[2])
        if steps:
            for step in steps:
                self.feetFollower.pushStep(step)
            self.feetFollower.generateTrajectory()
            self.setup()
